# 第三章 进程管理

**进程**：进程就是执行器的程序。但进程并不仅仅局限于一段可执行程序代码，通常还要包含其他资源，如：打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程，存放全局变量的数据段等。

**线程**：线程是进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组寄存器。内核调度的是线程，而不是进程。

**虚拟处理器和虚拟内存**：虚拟处理器给进程一种假象，让这些进程觉得自己在独享处理器；虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。

**fork函数**：在Linux系统中，进程的创建通常是fork()系统调用的结果，该系统通过复制一个现有进程来创建一个全新的进程。fork()系统调用从内核返回两次：一次回到父进程，另一次回到新产生的子进程。在现代Linux内核中，fork()实际上是由clone()系统调用实现的。

**任务队列（task list）**：内核把进程的列表存放在叫做任务队列的双向循环链表中。链表元素类型为`task_struct`，称为进程描述符，该结构定义在`<linux/sched.h>`文件中。

**进程描述符（task_struct）**：进程描述符中包含的数据能完整地描述一个正在执行的程序：它打开的文件，进程的地址空间，挂起的信号，进程的状态，还有其他更多消息。

**分配进程描述符**：在2.6以前的内核中，各个进程的`task_struct`存放在它们内核栈的尾端。用slab分配器动态生成`task_struct`时只需在栈底或栈顶创建一个新的结构`struct thread_info`。
```
struct thread_info{
	struct task_struct		*taask;
	struct exec_domain		*exec_domain;
	__u32				flags;
	__u32				status;
	__u32				cpu;
	int				preempt_count;
	mm_segment_t			addr_limit;
	struct restart_block		restart_block;
	void				*sysenter_return;
	int				uaccess_err;
}
```

**进程描述符**：内核通过一个唯一的进程标识值（PID）来标识每个进程。PID实际上是一个数，表示为pid_t隐含类型。内核把每个进程的PID存放在它们各自的进程描述符中。PID的最大数目为32768，可以通过修改/proc/sys/kernel/pid_max来修改上限。

**访问进程**：在内核中，访问进程通常需要获得指向其`task_struct`的指针，通过current宏可以找到当前正在运行的进程描述符。

当前进程：不通的硬件体系下查找当前进程的方法不同。有的硬件体系结构可以拿出一个专门寄存器来存放指向当前进程`task_struct`的指针，用于加快访问速度。而像x86这样的体系结构，就只能在内核栈的尾端创建`thread_info`结构，通过计算偏移间接地查找`task_struct`结构。

**进程状态**：进程描述符`task_struct`的`state`域描述了进程的当前状态。系统中的每个进程都必然处于以下五种进程状态中的一种。
 - **TASK_RUNNING**（运行）：进程是可执行的；它或者正在执行，或者在运行队列中等待执行。
 - **TASK_INTERRUPTIBLE**（可中断）：进程正在睡眠，等在某些条件的达成。一旦这些条件达成，内核就会把进程状态设置为运行。此时此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行。
 - **TASK_UNINTERRUPTIBLE**（不可中断）：除了不能被唤醒外，其他和可中断状态相同。这个状态通常在进程必须在等待是不受干扰或等待事件很快就会发生时出现。
 - **__TASK_TRACED**（被跟踪）：被其他进程跟踪的进程，例如通过`ptrace`对调试程序进程跟踪。
 - **__TASK_STOPPED**（停止）：进程停止运行。

**设置进程状态**：内核经常要调整某个进程的状态，这是最好使用`set_task_state(task, state)`函数：
```
set_task_state(task, state);	/* 将进程task的状态设置为state */
```
值得注意的是，`set_current_state(state)`与`set_task_state(current, state)`含义都是设置当前进程状态。

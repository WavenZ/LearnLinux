# 第三章 进程管理

**进程**：进程就是执行器的程序。但进程并不仅仅局限于一段可执行程序代码，通常还要包含其他资源，如：打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程，存放全局变量的数据段等。

**线程**：线程是进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组寄存器。内核调度的是线程，而不是进程。

**虚拟处理器和虚拟内存**：虚拟处理器给进程一种假象，让这些进程觉得自己在独享处理器；虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。

**fork函数**：在Linux系统中，进程的创建通常是fork()系统调用的结果，该系统通过复制一个现有进程来创建一个全新的进程。fork()系统调用从内核返回两次：一次回到父进程，另一次回到新产生的子进程。在现代Linux内核中，fork()实际上是由clone()系统调用实现的。

**任务队列（task list）**：内核把进程的列表存放在叫做任务队列的双向循环链表中。链表元素类型为`task_struct`，称为进程描述符，该结构定义在`<linux/sched.h>`文件中。

**进程描述符（task_struct）**：进程描述符中包含的数据能完整地描述一个正在执行的程序：它打开的文件，进程的地址空间，挂起的信号，进程的状态，还有其他更多消息。

<div align = center>
	<img src = "https://img-blog.csdnimg.cn/20191013225623705.png" width = 45%">
</div>

**分配进程描述符**：在2.6以前的内核中，各个进程的`task_struct`存放在它们内核栈的尾端。用slab分配器动态生成`task_struct`时只需在栈底或栈顶创建一个新的结构`struct thread_info`。

<div align = center>
	<img src = "https://img-blog.csdnimg.cn/20191013225742776.png" width = 45%">
</div>

```c
struct thread_info{
	struct task_struct		*taask;
	struct exec_domain		*exec_domain;
	__u32				flags;
	__u32				status;
	__u32				cpu;
	int				preempt_count;
	mm_segment_t			addr_limit;
	struct restart_block		restart_block;
	void				*sysenter_return;
	int				uaccess_err;
}
```

**进程描述符**：内核通过一个唯一的进程标识值（PID）来标识每个进程。PID实际上是一个数，表示为pid_t隐含类型。内核把每个进程的PID存放在它们各自的进程描述符中。PID的最大数目为32768，可以通过修改/proc/sys/kernel/pid_max来修改上限。

**访问进程**：在内核中，访问进程通常需要获得指向其`task_struct`的指针，通过current宏可以找到当前正在运行的进程描述符。

当前进程：不通的硬件体系下查找当前进程的方法不同。有的硬件体系结构可以拿出一个专门寄存器来存放指向当前进程`task_struct`的指针，用于加快访问速度。而像x86这样的体系结构，就只能在内核栈的尾端创建`thread_info`结构，通过计算偏移间接地查找`task_struct`结构。

**进程状态**：进程描述符`task_struct`的`state`域描述了进程的当前状态。系统中的每个进程都必然处于以下五种进程状态中的一种。
 - **TASK_RUNNING**（运行）：进程是可执行的；它或者正在执行，或者在运行队列中等待执行。
 - **TASK_INTERRUPTIBLE**（可中断）：进程正在睡眠，等在某些条件的达成。一旦这些条件达成，内核就会把进程状态设置为运行。此时此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行。
 - **TASK_UNINTERRUPTIBLE**（不可中断）：除了不能被唤醒外，其他和可中断状态相同。这个状态通常在进程必须在等待是不受干扰或等待事件很快就会发生时出现。
 - **__TASK_TRACED**（被跟踪）：被其他进程跟踪的进程，例如通过`ptrace`对调试程序进程跟踪。
 - **__TASK_STOPPED**（停止）：进程停止运行。

**设置进程状态**：内核经常要调整某个进程的状态，这是最好使用`set_task_state(task, state)`函数：
```c
set_task_state(task, state);	/* 将进程task的状态设置为state */
```
值得注意的是，`set_current_state(state)`与`set_task_state(current, state)`含义都是设置当前进程状态。

**进程上下文**：一般程序在用户空间执行，当一个程序执行了系统调用或者出发了某个异常，它就陷入了内核空间，此时称内核“代表进程执行”并处于进程上下文中。

**进程家族树**：在Linux系统中，所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程，该进程读取初始化脚本并执行其他的相关程序，最终完成系统启动的整个过程。

系统中的每个进程必有一个父进程。进程间的关系放在进程描述符中，每个`task_struct`都包含一个指向其父进程`task_struct`，叫做`parent`的指针，还包含一个称为`children`的子进程链表。

**进程创建**:Unix的进程创建很特别。
 - 许多其他的操作系统都提供了产生`spawn`进程的机制，首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。
 - Unix将上述步骤分解为两个单独的函数中取执行：fork()和exec()。首先，fork()通过拷贝当前进程创建一个子进程，子进程和父进程的区别在于PID、PPID和某些资源和统计量。exec()函数负责读取可执行文件并将其载入地址空间开始运行。

**写时拷贝**：Linux的fork（）使用写时拷贝页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不赋值整个进程地址空间，而是让父进程和子进程共享一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。

fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。

**fork()**:Linux通过`clone()`系统调用实现`fork()`。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源。

`fork()`、`vfork()`和`__clone()`库函数都根据各自需要的参数标志去调用`clone()`，然后用`clone`去调用`do_fork()`。

`do_fork()`完成了创建中的大部分工作，该函数调用`copy_process()`函数，然后让进程开始与运行。

`copy_process（）`函数完成的工作如下：
 - 1）调用dup_task_struct()为新进程创建一个内核栈、`thread_info`结构和`task_struct`，这些值与当前进程的值相同。
 - 2）检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超过给它分配的资源的限制。
 - 3）子进程的进程描述符内的许多成员都要被清0或者设为初始值。
 - 4)子进程的状态设置为`TASK_UNINTRERUPTIBLE`，以保证它不会投入运行。
 - 5）copy_process()调用copy_flags()以更新`task_struct`的`flags`成员，表明进程是否拥有超级用户权限的`PF_SUPERPRIV`标志被清零。表明进程还没有调用`exec()`函数的`PF_FORKNOEXEC`标志被设置。
 - 6）调用alloc_pid()为新进程分配一个有效的PID。
 - 7）根据传递给`clone()`的参数标志，`copy_process()`拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间。一般情况下，这些资源会被给定进程的所有线程共享；否则，这些资源对每个进程是不同的，因此被拷贝到这里。
 - 8)最后，`copy_process()`做扫尾工作并返回一个指向子进程的指针。

如果`copy_process()`函数成功返回，新创建的子进程被唤醒并让其投入运行。

**Linux线程**:Linux把所有的线程都当作进程来实现。内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程。相反，线程仅仅被视为一个与其他进程共享某些资源的进程。每个进程都拥有唯一隶属于自己的`task_struct`，所以在内核中，它看起来就像是一个普通的进程。

**线程创建**：线程的床架和普通进程的创建类似，只不过在调用`clone()`的时候需要传递一些参数标志来指明需要共享的资源：
```c
	clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);
```
上述代码产生的结果和调用`fork()`差不多，只是父子俩共享地址空间、文件系统资源、文件描述符和信号处理程序。

一个普通的`fork()`的实现是：
```c
	clone(SIGCHLD, 0);
```
而`vfork()`的实现是：
```c
	clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0);
```

**内核线程**：内核线程和普通的进程间的区别在于内核线程没有独立的地址空间，它们只在内核空间运行，从来不切换到用户空间中去。内核进程和普通进程一样，可以被调度，也可以被抢占。

**进程终结**：一般来说，进程的析构是自身引起的，它发生在进程调用`exit()`系统调用时，既可能显式调用这个系统调用，也可能隐式地从某个程序的主函数返回。

无论进程式怎样终结的，该任务大部分都要靠`do_exit()`来完成，它要做如下工作：
 - 1）将`task_struct`的标志成员设置为`PF_EXITING`。
 - 2）调用`del_timer_sync()`删除任一内核定时器。根据返回的结果，它确保没有定时器在排队，也没有定时器处理程序在运行。
 - 3）如果BSD的进程记账功能式开启的，`do_exit()`调用`acc_update_integrals()`来输出记账信息。
 - 4）调用`exit_mm()`函数释放进程占用的`mm_struct`，如果没有别的进程使用它们，就彻底释放它们。
 - 5）调用`sem__exit()`函数，如果进程排队等待IPC信号，它则离开队列。
 - 6）调用`exit_files()`和`exit_fs()`，以分别递减文件描述符、文件系统数据的引用计数。如果其中某个引用计数的数值降为0，则释放资源。
 - 7）把存放在`task_struct`的`exit_code`成员中的任务退出代码置为由`exit()`提供的退出代码，或者去完成任何其他由内核机制规定的退出动作。
 - 8）调用`exit_notify()`向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者`init`进程，并把进程状态设为`EXIT_ZOMBIE`。
 - 9）`do_exit()`调用`schedule()`切换到新的进程。

**删除进程描述符**：当最终要释放进程描述符时，`release_task()`会被调用，用以完成一下工作：
 - 1）它调用`__exit_signal()`，该函数调用`_unhash_process()`，后者又调用`detach_pid()`从`pidhash`上删除该进程，同时也要从任务列表中删除该进程。
 - 2）`_exit_signal()`释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录。
 - 3）如果这个进程时线程组的最后一个进程，并且领头进程已经死掉，那么`release_task()`就要通知僵死的领头进程的父进程。
 - 4）`release_task()`调用`put_task_struct()`释放进程内核栈和`thread_info`结构所占的页，并释放`task_struct`所占的`slab`高速缓存。
至此，进程描述符和所有进程独享的资源就全部释放掉了。

**进程上下文**：一般程序在用户空间执行，当一个程序执行了系统调用或者出发了某个异常，它就陷入了内核空间，此时称内核“代表进程执行”并处于进程上下文中。

**进程家族树**：在Linux系统中，所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程，该进程读取初始化脚本并执行其他的相关程序，最终完成系统启动的整个过程。

系统中的每个进程必有一个父进程。进程间的关系放在进程描述符中，每个`task_struct`都包含一个指向其父进程`task_struct`，叫做`parent`的指针，还包含一个称为`children`的子进程链表。

**进程创建**:Unix的进程创建很特别。
 - 许多其他的操作系统都提供了产生`spawn`进程的机制，首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。
 - Unix将上述步骤分解为两个单独的函数中取执行：fork()和exec()。首先，fork()通过拷贝当前进程创建一个子进程，子进程和父进程的区别在于PID、PPID和某些资源和统计量。exec()函数负责读取可执行文件并将其载入地址空间开始运行。

**写时拷贝**：Linux的fork（）使用写时拷贝页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不赋值整个进程地址空间，而是让父进程和子进程共享一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。

fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。

**fork()**:Linux通过`clone()`系统调用实现`fork()`。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源。

`fork()`、`vfork()`和`__clone()`库函数都根据各自需要的参数标志去调用`clone()`，然后用`clone`去调用`do_fork()`。

`do_fork()`完成了创建中的大部分工作，该函数调用`copy_process()`函数，然后让进程开始与运行。

`copy_process（）`函数完成的工作如下：
 - 1）调用dup_task_struct()为新进程创建一个内核栈、`thread_info`结构和`task_struct`，这些值与当前进程的值相同。
 - 2）检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超过给它分配的资源的限制。
 - 3）子进程的进程描述符内的许多成员都要被清0或者设为初始值。
 - 4)子进程的状态设置为`TASK_UNINTRERUPTIBLE`，以保证它不会投入运行。
 - 5）copy_process()调用copy_flags()以更新`task_struct`的`flags`成员，表明进程是否拥有超级用户权限的`PF_SUPERPRIV`标志被清零。表明进程还没有调用`exec()`函数的`PF_FORKNOEXEC`标志被设置。
 - 6）调用alloc_pid()为新进程分配一个有效的PID。
 - 7）根据传递给`clone()`的参数标志，`copy_process()`拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间。一般情况下，这些资源会被给定进程的所有线程共享；否则，这些资源对每个进程是不同的，因此被拷贝到这里。
 - 8)最后，`copy_process()`做扫尾工作并返回一个指向子进程的指针。

如果`copy_process()`函数成功返回，新创建的子进程被唤醒并让其投入运行。

**Linux线程**:Linux把所有的线程都当作进程来实现。内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程。相反，线程仅仅被视为一个与其他进程共享某些资源的进程。每个进程都拥有唯一隶属于自己的`task_struct`，所以在内核中，它看起来就像是一个普通的进程。

**线程创建**：线程的床架和普通进程的创建类似，只不过在调用`clone()`的时候需要传递一些参数标志来指明需要共享的资源：
```c
	clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);
```
上述代码产生的结果和调用`fork()`差不多，只是父子俩共享地址空间、文件系统资源、文件描述符和信号处理程序。

一个普通的`fork()`的实现是：
```c
	clone(SIGCHLD, 0);
```
而`vfork()`的实现是：
```c
	clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0);
```

**内核线程**：内核线程和普通的进程间的区别在于内核线程没有独立的地址空间，它们只在内核空间运行，从来不切换到用户空间中去。内核进程和普通进程一样，可以被调度，也可以被抢占。

**进程终结**：一般来说，进程的析构是自身引起的，它发生在进程调用`exit()`系统调用时，既可能显式调用这个系统调用，也可能隐式地从某个程序的主函数返回。

无论进程式怎样终结的，该任务大部分都要靠`do_exit()`来完成，它要做如下工作：
 - 1）将`task_struct`的标志成员设置为`PF_EXITING`。
 - 2）调用`del_timer_sync()`删除任一内核定时器。根据返回的结果，它确保没有定时器在排队，也没有定时器处理程序在运行。
 - 3）如果BSD的进程记账功能式开启的，`do_exit()`调用`acc_update_integrals()`来输出记账信息。
 - 4）调用`exit_mm()`函数释放进程占用的`mm_struct`，如果没有别的进程使用它们，就彻底释放它们。
 - 5）调用`sem__exit()`函数，如果进程排队等待IPC信号，它则离开队列。
 - 6）调用`exit_files()`和`exit_fs()`，以分别递减文件描述符、文件系统数据的引用计数。如果其中某个引用计数的数值降为0，则释放资源。
 - 7）把存放在`task_struct`的`exit_code`成员中的任务退出代码置为由`exit()`提供的退出代码，或者去完成任何其他由内核机制规定的退出动作。
 - 8）调用`exit_notify()`向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者`init`进程，并把进程状态设为`EXIT_ZOMBIE`。
 - 9）`do_exit()`调用`schedule()`切换到新的进程。

**删除进程描述符**：当最终要释放进程描述符时，`release_task()`会被调用，用以完成一下工作：
 - 1）它调用`__exit_signal()`，该函数调用`_unhash_process()`，后者又调用`detach_pid()`从`pidhash`上删除该进程，同时也要从任务列表中删除该进程。
 - 2）`_exit_signal()`释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录。
 - 3）如果这个进程时线程组的最后一个进程，并且领头进程已经死掉，那么`release_task()`就要通知僵死的领头进程的父进程。
 - 4）`release_task()`调用`put_task_struct()`释放进程内核栈和`thread_info`结构所占的页，并释放`task_struct`所占的`slab`高速缓存。
至此，进程描述符和所有进程独享的资源就全部释放掉了。

第四章 进程调度

**调度程序**:调度程序负责决定将哪个进程投入运行，何时运行以及运行多长时间。进程调度程序可看作在可运行态进程之间分配有限的处理器时间资源的内核子系统。

**多任务操作系统**：多任务操作系统就是能同时并发地交互执行多个进程的操作系统。多任务系统可以分为两类：非抢占式多任务和抢占式多任务。Linux提供了抢占式的多任务模式。

**时间片**：进程在被抢占之前能够运行的时间式预先设置好的，并且又一个专门的名字，叫进程的时间片。




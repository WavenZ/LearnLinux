# 第二章 从内核出发

**Linux内核命名**：`major.minor.pathch-build.desc`  （主版本号.次版本号.对minor的修改次数-编译次数.特殊信息）
 - 次版本号为奇数表示开发版，偶数表示稳定版
 - 每次对内核进行修订或者打一次补丁就递增版本号中的patch域
 - 对少量代码做了优化或者修改，并重新编译一次，就递增版本号中的build域

**内核开发的特点**：
 - 内核编程既不能访问C库也不能访问标准的C头文件
 - 内核编程时必须使用GNU C
 - 内核编程时缺乏像用户空间那样的内存保护机制。
 - 内核编程时难以执行浮点运算
 - 内核给每个进程只有一个很小的定长堆栈
 - 由于内核支持异步中断、抢占和SMP，因此必须时刻注意同步和并发。
 - 要考虑可移植性的重要性。

**头文件**：内核源代码文件不能包含外部头文件，就像它们不能用外部库一样。
 - 基本的头文件位于内核源代码树顶级目录下的include目录中。
 - 体系结构相关的头文件位于内核源代码树的arch/<architecture>/include/asm目录下。

**printk()函数**：内核代码无法调用printf()函数，可以利用printk()函数负责把格式化好的字符串拷贝到内核日志缓冲区上。（printk和printf的一个显著区别在于，printk允许我们通过指定一个标志来设置优先级）。

**GNU C**:内核开发者使用的C语言涵盖了ISO C99标准和GNU C拓展特性。
 - 内联函数inline：内核开发者通常把哪些对时间要求比较高，而本身长度又比较短的函数定义成内联函数。
 - 内联汇编：gcc编译器支持在C函数中嵌入汇编指令。当然，在内核编程的时候，只有知道对应的体系结构，才能使用这个功能。
 - 分支声明：gcc内建了一条指令用户优化条件选择分支。比如likely()和unlikely()

**内存保护机制**：内核中没有内存保护机制，内核中不应该去做访问非法内存，引用空指针等；内核中的内存不分页，也就是说没用掉一个字节，物理内存就减少一个字节。

**浮点运算**：除了一些极少的情况，不要在内核中使用浮点操作。

**内核栈**：内核栈的准确大小随体系结构而变，其容积小且固定。
 
**同步与并发**：内核很容易产生竞争，常用的解决方法是自旋锁和信号量。

## 进程间通信

进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。

IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享内存、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。

#### 1. 匿名管道（pipe）

pipe可用于具有亲缘关系的进程之间的通信，一般来说指的是父子进行进行通信，因此需要fork()来创建子进程。

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20190925114752783.png" width = "40%">
<div align = left>
  
上图是一个匿名管道的示意图，它有两个端，分别为**读和写**端，当一个进程向读端写入数据时，另一个进程就可以从写端读出数据，从而达到**进程间通信**的目的。

创建一个匿名管道很简单：
```c
#include <stdio.h>
#include <unistd.h>
...
  int fd[2];
  int ret = pipe(fd);
  if(ret < 0){
      printf("Create pip erroe!\n");
      /* Do something here ... */
  }
...
```
其中，`fd[0]`和`fd[1]`为两个文件描述符，其中`fd[0]`用于写，`fd[1]`用于读。

对于一个进程，当需要对利用管道进行写操作时，需要关闭`fd[1]`；当需要利用管道进行读操作时，关闭`fd[0]`。

下面在主进程中用`fork()`创建一个子进程，然后在主进程中向`fd[0]`写入数据，在子进程中从`fd[1]`中读取消息。

```c
include <stdio.h>
#include <unistd.h>

int main(){
        int fd[2];
        pid_t pid;
        char buff[20];
        int ret;

        printf("In process!\n");
        /* Create pip */
        ret = pipe(fd);
        if(ret < 0){
                printf("Create pip error!\n");
        }
        /* Create subprocess */
        pid = fork();
        if(pid < 0){
                printf("Fork error!\n");
        }

        if(pid > 0){
                close(fd[0]);
                write(fd[1], "Hello, son!\n", 12);
        }else{
                close(fd[1]);
                read(fd[0], buff, 20);
                printf("Get message: %s\n", buff);
        }


        return 0;
}
```
运行结果：
```c
root@linux:~/learn_os# ./pip
In process!
root@linux:~/learn_os# Get message: Hello, son!

```
上述代码中，父进程首先创建了一个管道`fd[2]`，然后利用`fork()`创建一个子进程，子进程将父线程的所有变量进行拷贝，于是将该管道也拷贝到了子进程中。

由于父进程需要通过管道发送消息，因此关闭`fd[0]`，然后从`fd[1]`发送信息；子进程需要从管道读取信息，因此关闭`fd[1]`，然后从`fd[0]`中读取信息。

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20190925155219977.png" width = "40%">
<div align = left>




